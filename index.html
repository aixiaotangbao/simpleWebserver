<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <img src="/static/timg.jpg" alt="小女孩" />
    <p>
        输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
        ```
        示例 1：
        输入：head = [1,3,2]
        输出：[2,3,1]
        限制：
        0 <= 链表长度 <= 10000
        ```
        解法：遍历链表，将链表中的值放到一个栈（先进后出）中，再将栈中中的值出栈放到一个数组中。
        遇到的问题：pop()不会返回栈顶元素，为了**安全性和效率**
        ->如果pop()返回栈顶元素，则必须按值返回，而不是按引用返回。按值返回效率低下，会在返回的过程中调用构造函数。
        所以采用了先用top()后用pop()
        ```c++
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */
        class Solution {
        public:
        vector<int> reversePrint(ListNode* head) {
        stack<int> list;
            vector<int> result;
                ListNode* pNode = head;
                while (pNode!= nullptr){
                list.push(pNode->val);
                pNode = pNode->next;
                }
                while(!list.empty()){
                int temp = list.top();
                result.push_back(temp);
                list.pop();
                }
                return result;
                }
                };
                写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。
                ```
                示例:

                输入: a = 1, b = 1
                输出: 2
                ```
                提示：

                - a, b 均可能是负数或 0
                - 结果不会溢出 32 位整数

                解法：使用异或运算和与运算模拟相加和进位运算

                ```C++
                class Solution {
                public:
                int add(int a, int b) {
                do{
                int sum = a ^ b;
                b = (unsigned int)(a & b) << 1;
                a = sum;
                }while(b != 0);
                return a;
                }
                };
                解法：遍历链表，将链表中的值放到一个栈（先进后出）中，再将栈中中的值出栈放到一个数组中。
                遇到的问题：pop()不会返回栈顶元素，为了**安全性和效率**
                ->如果pop()返回栈顶元素，则必须按值返回，而不是按引用返回。按值返回效率低下，会在返回的过程中调用构造函数。
                所以采用了先用top()后用pop()
                解法：遍历链表，将链表中的值放到一个栈（先进后出）中，再将栈中中的值出栈放到一个数组中。
                遇到的问题：pop()不会返回栈顶元素，为了**安全性和效率**
                ->如果pop()返回栈顶元素，则必须按值返回，而不是按引用返回。按值返回效率低下，会在返回的过程中调用构造函数。
                所以采用了先用top()后用pop()
                解法：遍历链表，将链表中的值放到一个栈（先进后出）中，再将栈中中的值出栈放到一个数组中。
                遇到的问题：pop()不会返回栈顶元素，为了**安全性和效率**
                ->如果pop()返回栈顶元素，则必须按值返回，而不是按引用返回。按值返回效率低下，会在返回的过程中调用构造函数。
                所以采用了先用top()后用pop()
                解法：遍历链表，将链表中的值放到一个栈（先进后出）中，再将栈中中的值出栈放到一个数组中。
                遇到的问题：pop()不会返回栈顶元素，为了**安全性和效率**
                ->如果pop()返回栈顶元素，则必须按值返回，而不是按引用返回。按值返回效率低下，会在返回的过程中调用构造函数。
                所以采用了先用top()后用pop()
                解法：遍历链表，将链表中的值放到一个栈（先进后出）中，再将栈中中的值出栈放到一个数组中。
                遇到的问题：pop()不会返回栈顶元素，为了**安全性和效率**
                ->如果pop()返回栈顶元素，则必须按值返回，而不是按引用返回。按值返回效率低下，会在返回的过程中调用构造函数。
                所以采用了先用top()后用pop()
                解法：遍历链表，将链表中的值放到一个栈（先进后出）中，再将栈中中的值出栈放到一个数组中。
                遇到的问题：pop()不会返回栈顶元素，为了**安全性和效率**
                ->如果pop()返回栈顶元素，则必须按值返回，而不是按引用返回。按值返回效率低下，会在返回的过程中调用构造函数。
                所以采用了先用top()后用pop()
                解法：遍历链表，将链表中的值放到一个栈（先进后出）中，再将栈中中的值出栈放到一个数组中。
                遇到的问题：pop()不会返回栈顶元素，为了**安全性和效率**
                ->如果pop()返回栈顶元素，则必须按值返回，而不是按引用返回。按值返回效率低下，会在返回的过程中调用构造函数。
                所以采用了先用top()后用pop()
                解法：遍历链表，将链表中的值放到一个栈（先进后出）中，再将栈中中的值出栈放到一个数组中。
                遇到的问题：pop()不会返回栈顶元素，为了**安全性和效率**
                ->如果pop()返回栈顶元素，则必须按值返回，而不是按引用返回。按值返回效率低下，会在返回的过程中调用构造函数。
                所以采用了先用top()后用pop()
                解法：遍历链表，将链表中的值放到一个栈（先进后出）中，再将栈中中的值出栈放到一个数组中。
                遇到的问题：pop()不会返回栈顶元素，为了**安全性和效率**
                ->如果pop()返回栈顶元素，则必须按值返回，而不是按引用返回。按值返回效率低下，会在返回的过程中调用构造函数。
                所以采用了先用top()后用pop()
                解法：遍历链表，将链表中的值放到一个栈（先进后出）中，再将栈中中的值出栈放到一个数组中。
                遇到的问题：pop()不会返回栈顶元素，为了**安全性和效率**
                ->如果pop()返回栈顶元素，则必须按值返回，而不是按引用返回。按值返回效率低下，会在返回的过程中调用构造函数。
                所以采用了先用top()后用pop()

                <center><embed src="/static/myPerson.pdf" width="850" height="600"></center>

    </p>

</body>
</html>